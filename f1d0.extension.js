"use strict";exports.id="f1d0",exports.ids=["f1d0"],exports.modules={1378:(e,t,i)=>{i.r(t),i.d(t,{SSHFileSystem:()=>g});var r=i(1017),s=i(9496),o=i(801),n=i(972),a=i(5618);const l=(0,n.RS)(1,{...n._$,maxErrorStack:4}),h=["/.vscode","/.vscode/","/.git/","/node_modules","/pom.xml","/app/src/main/AndroidManifest.xml","/build.gradle","/.devcontainer/devcontainer.json"];function d(e){if(h.some((t=>t===e||t.endsWith("/")&&e.startsWith(t))))return!0;for(const{uri:{path:t}}of s.workspace.workspaceFolders||[]){if(!e.startsWith(t))continue;let i=r.posix.relative(t,e);if(i.startsWith("/")||(i=`/${i}`),h.some((e=>e===i||e.endsWith("/")&&i.startsWith(e))))return!0}return!1}const c={write:["createdirectory","writefile","delete","rename"]};c.all=[...c.write,"readdirectory","readfile","stat"];class g{constructor(e,t,i){this.authority=e,this.sftp=t,this.config=i,this.onCloseEmitter=new s.EventEmitter,this.onDidChangeFileEmitter=new s.EventEmitter,this.closed=!1,this.closing=!1,this.copy=void 0,this.onClose=this.onCloseEmitter.event,this.onDidChangeFile=this.onDidChangeFileEmitter.event,this.logging=n.zW.scope(`SSHFileSystem(${e})`,!1),this.sftp.on("end",(()=>(this.closed=!0,this.onCloseEmitter.fire()))),this.logging.info("SSHFileSystem created");const r=(0,o.gV)((()=>{var e;this.debugFlags=`${(null===(e=(0,o.r0)("DEBUG_FS",this.config.flags))||void 0===e?void 0:e[0])||""}`.toLowerCase().split(/,\s*|\s+/g),this.debugFlags.includes("all")&&this.debugFlags.push("showignored","full","converted");let t=((0,o.r0)("FS_NOTIFY_ERRORS",this.config.flags)||["write"])[0];!0===t&&(t="all"),this.notifyErrorFlags="string"==typeof t?t.toLowerCase().split(/,\s*|\s+/g):[];for(const e of this.notifyErrorFlags){const t=c[e];t&&this.notifyErrorFlags.push(...t)}}));this.onClose((()=>r.dispose()))}disconnect(){this.closing=!0,this.sftp.end()}watch(e,t){return new s.Disposable((()=>{}))}async stat(e){const t=await(0,a.Vi)((t=>this.sftp.stat(e.path,t))).catch((t=>this.handleError("stat",e,t,!0))),{mtime:i=0,size:r=0}=t;let o=s.FileType.Unknown;return t.isFile()&&(o|=s.FileType.File),t.isDirectory()&&(o|=s.FileType.Directory),t.isSymbolicLink()&&(o|=s.FileType.SymbolicLink),{type:o,mtime:i,size:r,ctime:0}}async readDirectory(e){const t=await(0,a.Vi)((t=>this.sftp.readdir(e.path,t))).catch((t=>this.handleError("readDirectory",e,t,!0)));return Promise.all(t.map((async t=>{const i=e.with({path:`${e.path}${e.path.endsWith("/")?"":"/"}${t.filename}`}),r=40960==(61440&t.attrs.mode)?s.FileType.SymbolicLink:0;try{const e=(await this.stat(i)).type;return[t.filename,e|r]}catch(e){return this.logging.warning.withOptions(n._$)`Error in readDirectory for ${i}: ${e}`,[t.filename,s.FileType.Unknown|r]}})))}createDirectory(e){return(0,a.Vi)((t=>this.sftp.mkdir(e.path,t))).catch((t=>this.handleError("createDirectory",e,t,!0)))}readFile(e){return new Promise(((t,i)=>{const r=this.sftp.createReadStream(e.path,{autoClose:!0}),s=[];r.on("data",s.push.bind(s)),r.on("error",(t=>this.handleError("readFile",e,t,i))),r.on("close",(()=>{t(new Uint8Array(Buffer.concat(s)))}))}))}writeFile(e,t,i){return new Promise((async(i,r)=>{let o,n=!1;try{o=(await(0,a.Vi)((t=>this.sftp.stat(e.path,t)))).mode,n=!0}catch(t){if("No such file"===t.message){if(o=this.config.newFileMode,"string"==typeof o&&(o=Number(o)),"number"!=typeof o&&(o=436),Number.isNaN(o))throw new Error(`Invalid umask '${this.config.newFileMode}'`)}else this.handleError("writeFile",e,t),s.window.showWarningMessage(`Couldn't read the permissions for '${e.path}', permissions might be overwritten`)}const l=this.sftp.createWriteStream(e.path,{mode:o,flags:"w"});l.on("error",(t=>this.handleError("writeFile",e,t,r))),l.end(t,(()=>{this.onDidChangeFileEmitter.fire([{uri:e,type:n?s.FileChangeType.Changed:s.FileChangeType.Created}]),i()}))}))}async delete(e,t){const i=await this.stat(e),r=()=>this.onDidChangeFileEmitter.fire([{uri:e,type:s.FileChangeType.Deleted}]);return i.type&(s.FileType.SymbolicLink|s.FileType.File)?(0,a.Vi)((t=>this.sftp.unlink(e.path,t))).then(r).catch((t=>this.handleError("delete",e,t,!0))):i.type&s.FileType.Directory&&t.recursive?(0,a.Vi)((t=>this.sftp.rmdir(e.path,t))).then(r).catch((t=>this.handleError("delete",e,t,!0))):(0,a.Vi)((t=>this.sftp.unlink(e.path,t))).then(r).catch((t=>this.handleError("delete",e,t,!0)))}rename(e,t,i){return(0,a.Vi)((i=>this.sftp.rename(e.path,t.path,i))).then((()=>this.onDidChangeFileEmitter.fire([{uri:e,type:s.FileChangeType.Deleted},{uri:t,type:s.FileChangeType.Created}]))).catch((e=>this.handleError("rename",t,e,!0)))}handleError(e,t,i,r=!1){const o=2===i.code&&["stat"===e,d(t.path)];if(o&&o.includes(!0)&&!this.debugFlags.includes("disableignored")){if(i=s.FileSystemError.FileNotFound(t),this.debugFlags.includes("showignored")){const i=`${o[0]?"F":""}${o[1]?"A":""}`;this.logging.debug(`Ignored (${i}) FileNotFound error for ${e}: ${t}`,n.j7)}if(!0===r)throw i;return r?r(i):void 0}if(this.debugFlags.includes("full")?this.logging.debug.withOptions(l)`Error during ${e} ${t}: ${i}`:this.debugFlags.includes("minimal")&&this.logging.debug.withOptions({...n.j7,maxErrorStack:0})`Error during ${e} ${t}: ${i.name}: ${i.message}`,r&&"number"==typeof i.code){const e=i;2===i.code?i=s.FileSystemError.FileNotFound(t):3===i.code?i=s.FileSystemError.NoPermissions(t):(6===i.code||7===i.code)&&(i=s.FileSystemError.Unavailable(t)),i!==e&&this.debugFlags.includes("converted")&&n.zW.debug(`Error converted to: ${i}`)}if(this.notifyErrorFlags.includes(e.toLowerCase())&&s.window.showErrorMessage(`Error handling ${e} for: ${t}\n${i.message||i}`),!0===r)throw i;if(r)return r(i)}}}};
//# sourceMappingURL=f1d0.extension.js.map